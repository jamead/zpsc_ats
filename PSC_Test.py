import matplotlib.pyplot as plt
import numpy as np
from scipy import stats
from reportlab.lib.pagesizes import letter, inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Image, PageBreak, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors
import os
import subprocess  # Import subprocess module
import epics
from epics import caget,caput
import time

from reportlab.platypus import Table, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors
from reportlab.lib.units import inch

styles = getSampleStyleSheet()

props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)

# Helper function to return color-coded result
def color_result(result):
    if result == "PASS":
        return Paragraph("<b><font color='green'>PASS</font></b>", styles['Normal'])
    else:
        return Paragraph("<b><font color='red'>FAIL</font></b>", styles['Normal'])

###############################################################################################
# Setup Parameters for ACMI Calibration Report (Adjust these Parameters as Needed)
###############################################################################################

Title = 'Automated PSC Test Report'
CalDate = '8/18/2025'
ReportDate = '8/25/2025'
Engineer = 'Anthony Caracappa'
Assistant = 'Tom Chiesa'

ScopeMAN = 'Tektronix'
ScopeMOD = 'MSO64B'
ScopeSN =  'B027138'
ScopeCAL = '12/30/2025'

PulserMAN = 'HP'
PulserMOD = '8114A'
PulserSN = '3330 G 00691'
PulserCAL = '*See Note 1'

TimerMAN = 'SRS'
TimerMOD = 'DG645'
TimerSN = '003099'
TimerCAL = '4/23/2026'

AnalyzerMAN = 'Rohde & Schwarz'
AnalyzerMOD = 'FWS50'
AnalyzerSN = '101986'
AnalyzerCAL = '10/30/2025'

DmmMAN = 'Keithley'
DmmMOD = '2100'
DmmSN = '8020357'
DmmCAL = '3/20/2025'

AttenMAN = 'Minicircuits'
AttenMOD = 'VAT-6+'
Atten20 = '-6.0304dB'
Atten50 = '-5.9892dB'
Atten100 = '-6.0058dB'

SplitMAN = 'Minicircuits'
SplitMOD = 'ZFSC-2-1W-S+'

# File Names from the Data Collection Scripts:

fratio = 'LTBRatio.raw'        #File Generated during the ICT Ratio Measurements
facmi = 'LTBacmi.raw'          #File Generated during the ACMI Calibration Measurements
fnegative = 'LTBneg.raw'       #File Generated during the Inverted Polarity Measurements
fverify = 'LTBverify2.txt'      #File Generated during the Verification Measurements
freport = "PSCTest.pdf"        #File Generated by this script for the Calibration Report

# ACMI Power Supply Voltage Measurements (Done Manually):
Pos5VDC = 5.1109
Neg5VDC = -5.1132
Pos3p3VDC = 3.3695
Pos24VDC1 = 24.149
Pos24VDC2 = 24.133

# Closeout Values:

PLCupdated = 'DONE'
PLCsignature = 'DONE'
PLCSSValue = 'F6A8B43D'
PLCrun = 'DONE'
ACMIbypass = 'DONE'
ECNrequest = 'DONE'
ProcStatus = 'COMPLETED'

if os.path.exists(freport):
    x = input("\n\nFile Exists! Make sure this file is not in use then\nEnter '1' to overwrite or '0' to abort: ")
    if int(x)==1:
        try:
            os.rename(freport,freport)
            print("Available!")
        except OSError as e:
            print("****** ERROR ******\n\n"+freport+" is in use. Please close the file and try again.")
            exit()
    else:
        exit()

doc = SimpleDocTemplate(freport, pagesize=letter, rightMargin=30,leftMargin=30, topMargin=30,bottomMargin=18)
elements = []

tdata = []
tdata.append([Title])
tdata.append(["Procedure Performed on "+CalDate+" by "+Engineer+" and "+Assistant])
tdata.append(["Analysis Performed on "+ReportDate+" by "+Engineer])

ta=Table(tdata,6*inch,[0.4*inch,0.22*inch,0.22*inch],style=[
                ('BACKGROUND',(0,0),(0,0),colors.lemonchiffon),
                ('VALIGN',(0,0),(0,0),'MIDDLE'),
                ('LINEABOVE',(0,1),(0,1),2,colors.black),
                ('FONTSIZE', (0,0), (0,0), 14),
                ('GRID',(0,0),(-1,-1),1,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ])

elements.append(ta)

##############################################################################################
# Test DAC
##############################################################################################
# Update these as needed
lab_number = {2}  
commanded_value = 1.000
tolerance = 0.1

# Zero DACs Initially...
epics.caput("lab{2}Chan1:DAC_SetPt-SP", 0.0)
epics.caput("lab{2}Chan2:DAC_SetPt-SP", 0.0)
epics.caput("lab{2}Chan3:DAC_SetPt-SP", 0.0)
epics.caput("lab{2}Chan4:DAC_SetPt-SP", 0.0)
time.sleep(3)

# Array to store DAC readback values
dac_rdbck_chan = []

for chan_num in range(1, 5):  # Chan1 to Chan4
    pv_base = f"lab{lab_number}Chan{chan_num}"
    pv_name = f"{pv_base}:DAC_SetPt-SP"

    # Set the DAC
    caput(pv_name, commanded_value)
    time.sleep(3)
    
    # Get the DAC readback value of the PV
    pv_base = f"lab{lab_number}Chan{chan_num}"
    pv_name = f"{pv_base}:DAC-I"
    dac_rdbck = caget(pv_name)
    print(f"{dac_rdbck:.6f}")
    
    # Store the result in the list
    dac_rdbck_chan.append(dac_rdbck)
    print("dac_rdbck:",dac_rdbck_chan[chan_num-1])

    # Check if value was successfully retrieved
    if dac_rdbck is None:
        print(f"Failed to read PV: {pv_name}")
        continue

    # Print the result to the terminal with 5 decimal places
    print(f'The current value of PV "{pv_name}" is: {dac_rdbck:.6f}')

    # Check if the readback value is within tolerance
    if abs(dac_rdbck - commanded_value) <= tolerance:
        print(f"Readback OK: {dac_rdbck:.6f} is within ±{tolerance} of {commanded_value:.6f}")
    else:
        print(f"FAILURE !!! : Readback {dac_rdbck:.5f} is OUTSIDE ±{tolerance} of {commanded_value:.6f}")




# Run Joe's 10 Hz Data Collection Script to take DCCT ppm measurements
subprocess.run(['python3', 'psc_read_sa_all_chans.py', 'lab{2}' , '10', 'data.txt' ])  # Run the psc_read_sa.py script to collect 10 Hz data




'''
tdata = []
tdata.append(["Setup Parameters for All Measurements","",""])
tdata.append(["Oscilloscope","Manufacturer",ScopeMAN])
tdata.append(["","Model Number",ScopeMOD])
tdata.append(["","Serial Number",ScopeSN])
tdata.append(["","Calibration Expiration",ScopeCAL])
tdata.append(["Fast HV Pulser","Manufacturer",PulserMAN])
tdata.append(["","Model Number",PulserMOD])
tdata.append(["","Serial Number",PulserSN])
tdata.append(["","Calibration Expiration",PulserCAL])
tdata.append(["Gate / Delay Generator","Manufacturer",TimerMAN])
tdata.append(["","Model Number",TimerMOD])
tdata.append(["","Serial Number",TimerSN])
tdata.append(["","Calibration Expiration",TimerCAL])
tdata.append(["Spectrum Analtzer","Manufacturer",AnalyzerMAN])
tdata.append(["","Model Number",AnalyzerMOD])
tdata.append(["","Serial Number",AnalyzerSN])
tdata.append(["","Calibration Expiration",AnalyzerCAL])
tdata.append(["6dB Attenuator","Manufacturer",AttenMAN])
tdata.append(["","Model Number",AttenMOD])
tdata.append(["","Attenuation @ 20MHz",Atten20])
tdata.append(["","Attenuation @ 50MHz",Atten50])
tdata.append(["","Attenuation @ 100MHz",Atten100])
tdata.append(["Splitter /Combiner","Manufacturer",SplitMAN])
tdata.append(["","Model Number",SplitMOD])
tdata.append(["Personnel","Cognizant Engineer",Engineer])
tdata.append(["","Trained Assistant",Assistant])
tdata.append(["Input Files","ICT Ratio",fratio])
tdata.append(["","ACMI Calibration",facmi])
tdata.append(["","Inverted Polarity",fnegative])
tdata.append(["","Calibration Verification",fverify])
tdata.append(["Output Files","ACMI Report",freport])

mess = "*Note 1:  The HP8114A HV Pulser is not used to perform any measurements in this\n"
mess +=" procedure and therefore does not need to be calibrated.  The pulses produced by\n"
mess +=" this device are measured by the other calibrated devices listed above.\n"

tdata.append([mess,"",""])
rowH = []
for i in range(0,31):
    rowH.append(0.22*inch)
rowH.append(0.75*inch)

elements.append(Spacer(width=1,height=0.1*inch))
t0=Table(tdata,2*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(2,0)),
                ('BACKGROUND',(0,0),(2,0),colors.lemonchiffon),
                ('LINEABOVE',(0,1),(2,1),2,colors.black),
                ('SPAN',(0,1),(0,4)),
                ('LINEABOVE',(0,5),(2,5),2,colors.black),
                ('SPAN',(0,5),(0,8)),
                ('LINEABOVE',(0,9),(2,9),2,colors.black),
                ('SPAN',(0,9),(0,12)),
                ('LINEABOVE',(0,13),(2,13),2,colors.black),
                ('SPAN',(0,13),(0,16)),
                ('LINEABOVE',(0,17),(2,17),2,colors.black),
                ('SPAN',(0,17),(0,21)),
                ('LINEABOVE',(0,22),(2,22),2,colors.black),
                ('SPAN',(0,22),(0,23)),
                ('LINEABOVE',(0,24),(2,24),2,colors.black),
                ('SPAN',(0,24),(0,25)),
                ('LINEABOVE',(0,26),(2,26),2,colors.black),
                ('SPAN',(0,26),(0,29)),
                ('LINEABOVE',(0,30),(2,30),2,colors.black),
                ('SPAN',(0,31),(2,31)),
                ('LINEABOVE',(0,31),(2,31),2,colors.black),
                ('GRID',(0,0),(-1,-1),1,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('VALIGN',(0,1),(0,30),'MIDDLE'),
                ('BACKGROUND',(0,1),(1,30),colors.lemonchiffon),
                ('BACKGROUND',(0,31),(2,31),colors.lightblue),
                ])

elements.append(t0)
elements.append(PageBreak())
'''

# DAC Readback Check Report Table
tdata = []
tdata.append(["DAC Readback Measurements","",""])


PSpass = 0

# Loop through channels
for i in range(4):
    channel_num = i + 1
    readback = dac_rdbck_chan[i]

    # Add channel info row
    tdata.append([f"Channel {channel_num}\n1.0 Amp Command", "Readback Value:", f"{readback:.6f}"])

    # Check tolerance
    if (commanded_value - tolerance) <= readback <= (commanded_value + tolerance):
        result = "PASS"
        PSpass += 1
    else:
        result = "FAIL"

    # Add result row with color formatting
    tdata.append(["", "Within tolerance?", color_result(result)])




tps = Table(tdata, 2*inch, 0.22*inch, style=[
    ('SPAN',(0,0),(2,0)),
    ('BACKGROUND',(0,0),(2,0),colors.lemonchiffon),
    ('LINEABOVE',(0,1),(2,1),2,colors.black),
    ('SPAN',(0,1),(0,2)),
    ('LINEABOVE',(0,3),(2,3),2,colors.black),
    ('SPAN',(0,3),(0,4)),
    ('LINEABOVE',(0,5),(2,5),2,colors.black),
    ('SPAN',(0,5),(0,6)),
    ('LINEABOVE',(0,7),(2,7),2,colors.black),
    ('SPAN',(0,7),(0,8)),
    # REMOVE OR COMMENT OUT styles for rows beyond index 8
    # ('LINEABOVE',(0,9),(2,9),2,colors.black),
    # ('SPAN',(0,9),(0,10)),
    # ('LINEABOVE',(0,11),(2,11),2,colors.black),
    # ('SPAN',(0,11),(2,11)),
    # ('LINEABOVE',(0,12),(2,12),2,colors.black),
    # ('SPAN',(0,12),(0,15)),
    ('GRID',(0,0),(-1,-1),1,colors.black),
    ('BOX',(0,0),(-1,-1),2,colors.black),
    ('BACKGROUND',(0,1),(1,8),colors.lemonchiffon),
])

elements.append(Spacer(width=1,height=0.1*inch))
elements.append(tps)
elements.append(PageBreak())



###############################################################################################
# EVR Timestamp Test
###############################################################################################

def read_pv_multiple_times(pv_name, num_reads=10, delay=1.0):
    """
    Reads a PV multiple times and stores the results in a list.

    :param pv_name: The name of the PV to read.
    :param num_reads: Number of times to read the PV.
    :param delay: Delay between reads (in seconds).
    :return: List of PV values.
    """
    pv_values = []
    for i in range(num_reads):
        value = caget(pv_name)
        print(f"Read {i+1}: {value}")
        pv_values.append(value)
        time.sleep(delay)
    return pv_values

# Replace with an actual PV on your system
pv_name = "lab{2}TS-S-I"

# Read PV values
pv_values = read_pv_multiple_times(pv_name, num_reads=10, delay=1.0)

# Optional: Check if the values increment properly
def check_pv_increment(pv_values, max_step=10):
    for i in range(1, len(pv_values)):
        diff = pv_values[i] - pv_values[i - 1]
        if diff < 0 or diff > max_step:
            print(f"FAIL at index {i}: prev={pv_values[i-1]}, current={pv_values[i]}")
            return 'FAIL'
    return 'PASS'

result = check_pv_increment(pv_values)
print(f"Result: {result}")



# Build the PDF Output file
doc.build(elements)

###############################################################################################
#  Start Processing the Ratio Raw Data File
###############################################################################################
'''
with open(fratio) as f:
    L = f.readlines()
    L = [x.strip('\n') for x in L]

Ratio = []
tdata = []
rowH = []
tdata.append(['Test Pulses Measurements for ICT Ratio', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\nAmpl (V)','Integral\nAvg (nVS)','Integral\nStd (nVS)','Charge\nAvg (nC)','Charge\nStd (nC)'])
rowH.append(0.4*inch)

Vpulser = []
Itest = []
Qtest = []
for i in range(0,21):
    Qscope = []
    Iscope = []
    Vscope = []
    for j in range(0,25):
        Z = L[i*25 + j + 1].split(",")
        if(len(Z)==5):
            Vscope.append(float(Z[2]))
            Iscope.append(float(Z[3]))
            Qscope.append(float(Z[4]))
    tdata.append([round(np.mean(Vscope),3),round(np.mean(Iscope),3),round(np.std(Iscope),4),round(np.mean(Qscope),3),round(np.std(Qscope),4)])
    rowH.append(0.22*inch)
    Vpulser.append(round(np.mean(Vscope),3))
    Itest.append(round(np.mean(Iscope),3))
    Qtest.append(round(np.mean(Qscope),3))
mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  Pulses measured\n"
mess +="directly by the MSO64B Scope with sample rate 3.125GS/S\n"
mess +="and an ADC resolution of 14-bits."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The average and standard deviation are based on 25\n"
mess +="repeated measurements made by the MSO64B Scope for\n"
mess +="each amplitude setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)

t1=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,23),(4,23)),
                ('BACKGROUND',(0,23),(4,23),colors.lemonchiffon),
                ('SPAN',(0,24),(4,24)),
                ('BACKGROUND',(0,24),(4,24),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,22),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,23),(4,23),2,colors.black),
                ('LINEABOVE',(0,24),(4,24),2,colors.black),
                ('LINEBEFORE',(1,1),(1,22),2,colors.black),
                ])

elements.append(t1)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup1.png",'rb')
elements.append(Image(f,width=6*inch, height=2.75*inch))
elements.append(PageBreak())

tdata = []
rowH = []
tdata.append(['Output Pulses Measurements for ICT Ratio', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\nAmpl (V)','Integral\nAvg (nVS)','Integral\nStd (nVS)','Charge\nAvg (nC)','Charge\nStd (nC)'])
rowH.append(0.4*inch)

Qict = []
Iict = []
Vpul = []
for i in range(0,21):
    Qscope = []
    Iscope = []
    Vscope = []
    for j in range(0,25):
        Z = L[i*25 + j + 527].split(",")
        if(len(Z)==5):
            Vscope.append(float(Z[2]))
            Iscope.append(float(Z[3]))
            Qscope.append(float(Z[4]))
        else:
            print("Error")
            exit()
    Qict.append(round(np.mean(Qscope),3))
    Iict.append(round(np.mean(Iscope),3))
    tdata.append([round(np.mean(Vscope),3),round(np.mean(Iscope),3),round(np.std(Iscope),4),round(np.mean(Qscope),3),round(np.std(Qscope),4)])
    rowH.append(0.22*inch)
print(Qict)
mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  ICT Output Pulses\n"
mess +="measured directly by the MSO64B Scope with sample rate\n"
mess +="of 3.125GS/S and an ADC resolution of 14-bits."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The average and standard deviation are based on 25\n"
mess +="repeated measurements made by the MSO64B Scope for\n"
mess +="each amplitude setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)

t2=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,23),(4,23)),
                ('BACKGROUND',(0,23),(4,23),colors.lemonchiffon),
                ('SPAN',(0,24),(4,24)),
                ('BACKGROUND',(0,24),(4,24),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,22),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,23),(4,23),2,colors.black),
                ('LINEABOVE',(0,24),(4,24),2,colors.black),
                ('LINEBEFORE',(1,1),(1,22),2,colors.black),
                ])

elements.append(t2)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup2.png",'rb')
elements.append(Image(f,width=6.7*inch, height=3*inch))
elements.append(PageBreak())

fr,axr = plt.subplots(1,1,figsize=(5,5))
Ratio = np.divide(Qtest,Qict)
FitCoef = np.corrcoef(Qtest,Qict)
axr.plot(Qict,Qtest,'-o',markersize=6)
axr.grid(color='lightgray',linestyle='-',linewidth=1)
axr.set_xlabel("ICT Output Charge (nC)")
axr.set_ylabel("ICT Test Charge (nC)")
axr.set_title("Ratio Measurement for ICT")

pfit = np.polyfit(Qict,Qtest,1)
axr.text(0.05, 0.93, 'Linear Fit of Data:',
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
axr.text(0.05, 0.86, 'Slope:'+str(round(pfit[0],2)),
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
axr.text(0.05, 0.79, 'Intercept:'+str(round(pfit[1],3)),
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
axr.text(0.05, 0.72, 'Correlation:'+str(round(FitCoef[0][1],5)),
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)

axr.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
Rpass=0
if(pfit[0]<40.8 and pfit[0]>39.2):
    result='PASS'
    Rpass=Rpass+1
axr.text(0.4, 0.31, '39.2 < Slope < 40.8 ? '+result,
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(pfit[1]<0.2 and pfit[0]>-0.2):
    result='PASS'
    Rpass=Rpass+1
axr.text(0.4, 0.24, '-0.2 < Intercept < 0.2 ? '+result,
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Rpass=Rpass+1
axr.text(0.4, 0.17, 'Correlation > 0.998 ? '+result,
    transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Rpass==3):
    result='PASS'
axr.text(0.3, 0.1, 'Ratio Measurement ? '+result,
    transform=axr.transAxes, fontsize=14,verticalalignment='top', bbox=props)

plt.savefig("ICTRatio.png")

f = open("ICTRatio.png",'rb')

elements.append(Image(f,width=5*inch, height=5*inch))

fr,axr = plt.subplots(1,1,figsize=(5,5))

axr.plot(Qtest[0:len(Qict)],Ratio,'-o',markersize=6)
axr.grid(color='lightgray',linestyle='-',linewidth=1)
axr.set_xlabel("ICT Output Charge (nC)")
axr.set_ylabel("Ratio Qtest/Qict")
axr.set_title("Ratio vs. ICT Charge")

mess = 'Note: Most of the variation in\nthe Ratio is known to be\ndue to small inaccuracies in\n'
mess= mess+'scope when changes in the\nvertical scale setting are made.\n'
mess= mess+'These inaccuracies are on\nthe order of 1%'
axr.text(0.24, 0.95, mess,transform=axr.transAxes, fontsize=10,verticalalignment='top', bbox=props)

plt.savefig("ICTRatioVsVpulse.png")

f = open("ICTRatioVsVpulse.png",'rb')

elements.append(Image(f,width=5*inch, height=5*inch))
elements.append(PageBreak())

print("Hello...1")

tdata = []
rowH = []
tdata.append(['Measurements for ICT Qin and Qout', '',''])
rowH.append(0.22*inch)
tdata.append(['Qin\n(nC)','Qout\n(nC)','Ratio\n(Qin/Qout)'])
rowH.append(0.4*inch)

for i in range(0,len(Qtest)):
    tdata.append([str(Qtest[i]),str(Qict[i]),str(round(Qtest[i]/Qict[i],3))])
    rowH.append(0.22*inch)
    
t3=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(2,0)),
                ('BACKGROUND',(0,0),(2,0),colors.lemonchiffon),
                ('SPAN',(0,23),(2,23)),
                ('SPAN',(0,24),(2,24)),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(2,1),2,colors.black),
                ('LINEABOVE',(0,2),(2,2),2,colors.black),
                ('LINEABOVE',(0,23),(2,23),2,colors.black),
                ('LINEABOVE',(0,24),(2,24),2,colors.black),
                ])

elements.append(t3)
elements.append(PageBreak())

print("Hello...2")
###########################################################################################
# Start Processing the ACMI Calibration Raw Data File for Normal Beam
###########################################################################################
with open(facmi) as f:
    L = f.readlines()
    L = [x.strip('\n') for x in L]

tdata = []
rowH = []
tdata.append(['Test Pulses Measurements for ACMI Calibration', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\nAmpl (V)','Integral\nAvg (nVS)','Integral\nStd (nVS)','Charge\nAvg (nC)','Charge\nStd (nC)'])
rowH.append(0.4*inch)

Vpulser = []
Itest = []
Qtest = []
for i in range(0,23):
    Qscope = []
    Iscope = []
    Vscope = []
    for j in range(0,25):
        Z = L[i*25 + j + 1].split(",")
        print(Z)
        if(len(Z)==5):
            Vscope.append(float(Z[2]))
            Iscope.append(float(Z[3]))
            Qscope.append(float(Z[4]))
            #print(Z[2],float(Z[3]),float(Z[4]))
    tdata.append([round(np.mean(Vscope),3),round(np.mean(Iscope),3),round(np.std(Iscope),4),round(np.mean(Qscope),3),round(np.std(Qscope),4)])
    rowH.append(0.22*inch)
    Vpulser.append(round(np.mean(Vscope),3))
    Itest.append(round(np.mean(Iscope),3))
    Qtest.append(round(np.mean(Qscope),3))
print("Hello...3")
mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  Pulses measured\n"
mess +="directly by the MSO64B Scope with sample rate 3.125GS/S\n"
mess +="and an ADC resolution of 14-bits."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The average and standard deviation are based on 10\n"
mess +="repeated measurements made by the MSO64B Scope for\n"
mess +="each amplitude setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)
    
t4=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,25),(4,25)),
                ('BACKGROUND',(0,25),(4,25),colors.lemonchiffon),
                ('SPAN',(0,26),(4,26)),
                ('BACKGROUND',(0,26),(4,26),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,24),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,25),(4,25),2,colors.black),
                ('LINEABOVE',(0,26),(4,26),2,colors.black),
                ('LINEBEFORE',(1,1),(1,24),2,colors.black),
                ])

elements.append(t4)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup1.png",'rb')
elements.append(Image(f,width=6*inch, height=2.75*inch))
elements.append(PageBreak())

tdata = []
rowH = []
tdata.append(['ADC Measurements from ACMI for Normal Beam Polarity', '','','','','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\n(Volts)','Qin\n(nC)','Beam','','Self Test (A-B)','','Self Test (B-A)',''])
rowH.append(0.22*inch)
tdata.append(['','','ADCA','ADCB','ADCA','ADCB','ADCA','ADCB'])
rowH.append(0.22*inch)
print("Hello...4")
Vpulser = []
Qtest = []
BeamA = []
BeamB = []
STABA = []
STABB = []
STBAA = []
STBAB = []

for i in range(0,23):
    Qn = []
    BAn = []
    BBn = []
    STABAn = []
    STABBn= []
    STBAAn = []
    STBABn = []
    Vpulser.append(i+1)
    for j in range(0,16):
        Z = L[i*16 + j + 577].split(",")
        if(len(Z)==9):
            Qn.append(float(Z[2]))
            BAn.append(float(Z[3]))
            BBn.append(float(Z[4]))
            STABAn.append(float(Z[5]))
            STABBn.append(float(Z[6]))
            STBAAn.append(float(Z[7]))
            STBABn.append(float(Z[8]))
    tdata.append([(i+1),round(np.mean(Qn),3),round(np.mean(BAn),1),round(np.mean(BBn),1),round(np.mean(STABAn),1),round(np.mean(STABBn),1),round(np.mean(STBAAn),1),round(np.mean(STBABn),1)])
    rowH.append(0.22*inch)

    Qtest.append(round(np.mean(Qn),3))
    BeamA.append(round(np.mean(BAn),3))
    BeamB.append(round(np.mean(BBn),3))
    STABA.append(round(np.mean(STABAn),3))
    STABB.append(round(np.mean(STABBn),3))
    STBAA.append(round(np.mean(STBAAn),3))
    STBAB.append(round(np.mean(STBABn),3))
print("Hello...5")    
mess = "HP8114A Pulse Generator was setup to produce 50 nSec wide pulses at the indicated voltages.\n"
mess +="Pulser connected to ICT Test Input.  ICT Output connected to ACMI Input.  ADC values read  \n"
mess +="from ACMI PLC over network using Python script."
tdata.append([mess,"","","","","","",""])
rowH.append(0.55*inch)
mess = "The averages are based on 16 repeated measurements made by the ACMI system for each amplitude\n"
mess +="setting of the HP8114A Pulse Generator."
tdata.append([mess,"","","","","","",""])
rowH.append(0.4*inch)

t5=Table(tdata,0.8*inch,rowH,style=[
                ('SPAN',(0,1),(0,2)),
                ('SPAN',(1,1),(1,2)),
                ('SPAN',(2,1),(3,1)),
                ('SPAN',(4,1),(5,1)),
                ('SPAN',(6,1),(7,1)),
                ('SPAN',(0,0),(7,0)),
                ('BACKGROUND',(0,0),(7,0),colors.lemonchiffon),
                ('SPAN',(0,26),(7,26)),
                ('BACKGROUND',(0,26),(7,26),colors.lemonchiffon),
                ('SPAN',(0,27),(7,27)),
                ('BACKGROUND',(0,27),(7,27),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,25),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(7,1),2,colors.black),
                ('LINEABOVE',(0,2),(7,2),2,colors.black),
                ('LINEABOVE',(0,3),(7,3),2,colors.black),
                ('LINEABOVE',(0,26),(7,26),2,colors.black),
                ('LINEABOVE',(0,27),(7,27),2,colors.black),
                ('LINEBEFORE',(1,1),(1,25),2,colors.black),
                ('LINEBEFORE',(2,1),(2,25),2,colors.black),
                ('LINEBEFORE',(4,1),(4,25),2,colors.black),
                ('LINEBEFORE',(6,1),(6,25),2,colors.black),
                ])

elements.append(t5)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup3.png",'rb')
elements.append(Image(f,width=6.7*inch, height=3*inch))
elements.append(PageBreak())
print("Hello...6")
SAT = []
Qsat = []
for i in range(20,23):
    if(BeamA[i]==2047):
        SAT.append(BeamA[i])
        Qsat.append(Qtest[i])
fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest,BeamA,'-o',markersize=6,label='ADC Data')
ax.plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Beam ACMI ADCA (Cnts)")
ax.legend(loc='lower right')
result='FAIL'
Ppass=0
if(len(SAT)==3):
    result='PASS'
    Ppass=Ppass+1
ax.text(0.05, 0.95, 'PASS / FAIL Test:\nADCA Saturated for 3\nlargest Charges ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.tight_layout()
plt.savefig("Positive1.png")
f = open("Positive1.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

SAT = []
Qsat = []
for i in range(20,23):
    if(STABA[i]==2047):
        SAT.append(STABA[i])
        Qsat.append(Qtest[i])
elements.append(Spacer(width=1,height=0.1*inch))
fr,ax = plt.subplots(1,2,figsize=(7,4))
ax[0].plot(Qtest,STABA,'-o',markersize=6,label='ADC Data')
ax[0].plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax[0].grid(True)
ax[0].set_xlabel("Qin (nC)")
ax[0].set_ylabel("ST(A-B) ACMI ADCA (Cnts)")
ax[0].legend(loc='lower right')
result='FAIL'
if(len(SAT)==3):
    result='PASS'
    Ppass=Ppass+1
ax[0].text(0.05, 0.95, 'PASS / FAIL Test:\nADCA Saturated for 3\nlargest Charges ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
print("Hello...7")
SAT = []
Qsat = []
for i in range(20,23):
    if(STBAB[i]==2047):
        SAT.append(STBAB[i])
        Qsat.append(Qtest[i])
ax[1].plot(Qtest,STBAB,'-o',markersize=6, label='ADC Data')
ax[1].plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax[1].grid(True)
ax[1].set_xlabel("Qin (nC)")
ax[1].set_ylabel("ST(B-A) ACMI ADCB (Cnts)")
ax[1].legend(loc='lower right')
result='FAIL'
if(len(SAT)==3):
    result='PASS'
    Ppass=Ppass+1
ax[1].text(0.05, 0.95, 'PASS / FAIL Test:\nADCB Saturated for 3\nlargest Charges ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.tight_layout()
plt.savefig("Positive2.png")
f = open("Positive2.png",'rb')
elements.append(Image(f,width=7*inch, height=4*inch))
elements.append(PageBreak())

Beam = np.subtract(BeamA[0:18],BeamB[0:18])
STAB = np.subtract(STABA[0:18],STABB[0:18])
STBA = np.subtract(STBAB[0:18],STBAA[0:18])
Qtest = Qtest[0:18]
print("Hello...8")
fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Beam,Qtest,'-o',linewidth=3,markersize=6,label='ADC Data')
ax.grid(True)
ax.set_ylabel("Qin (nC)")
ax.set_xlabel("Beam (A-B) (Cnts)")
pfit = np.polyfit(Beam,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(Beam,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*Beam[k] + pfit[0]*Beam[k]*Beam[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quadratic: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax.text(0.05, 0.93, mess,transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
PLCquad = int(1000000*pfit[0])
PLClinear = int(10000*pfit[1])
PLCoffset = int(pfit[2])
mess = 'PLC Values:\nQUAD: '+str(PLCquad)+'\nLIN: '+str(PLClinear)+'\nOFF:'+str(PLCoffset)
ax.text(0.05, 0.7, mess,transform=ax.transAxes, fontsize=14,verticalalignment='top', bbox=props)
ax.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Ppass=Ppass+1
ax.text(0.5, 0.31, 'Correlation > 0.998 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Ppass=Ppass+1
ax.text(0.5, 0.24, 'RMSE < 100pC ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax.plot(Beam,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax.legend(loc='lower right')
plt.tight_layout()
plt.savefig("Negative3.png")
f = open("Negative3.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

fr,ax = plt.subplots(1,2,figsize=(7,4))
ax[0].plot(STAB,Qtest,'-o',linewidth=3,markersize=6,label='ADC Data')
ax[0].grid(True)
ax[0].set_ylabel("Qin (nC)")
ax[0].set_xlabel("Self Test(A-B) (Cnts)")
pfit = np.polyfit(STAB,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(STAB,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*STAB[k] + pfit[0]*STAB[k]*STAB[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quad: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax[0].text(0.05, 0.93, mess,transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[0].text(0.45, 0.42, 'PASS / FAIL Tests:',
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Ppass=Ppass+1
ax[0].text(0.4, 0.33, 'Corr>0.998 ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Ppass=Ppass+1
ax[0].text(0.4, 0.24, 'RMSE<100pC ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[0].plot(STAB,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax[0].legend(loc='lower right')

ax[1].plot(STBA,Qtest,'-o',linewidth=3,markersize=6, label='ADC Data')
ax[1].grid(True)
ax[1].set_ylabel("Qin (nC)")
ax[1].set_xlabel("Self Test(B-A) (Cnts)")
pfit = np.polyfit(STBA,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(STBA,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*STBA[k] + pfit[0]*STBA[k]*STBA[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quad: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax[1].text(0.05, 0.93, mess,transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[1].text(0.45, 0.42, 'PASS / FAIL Tests:',
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Ppass=Ppass+1
ax[1].text(0.4, 0.33, 'Corr>0.998 ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Ppass=Ppass+1
ax[1].text(0.4, 0.24, 'RMSE<100pC ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[1].plot(STBA,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax[1].legend(loc='lower right')

plt.tight_layout()
plt.savefig("Negative4.png")
f = open("Negative4.png",'rb')
elements.append(Image(f,width=7*inch, height=4*inch))
elements.append(PageBreak())

###########################################################################################
# Start Processing the ACMI Calibration Raw Data File for Negative Beam Polarity
###########################################################################################
with open(fnegative) as f:
    L = f.readlines()
    L = [x.strip('\n') for x in L]

tdata = []
rowH = []
tdata.append(['Test Pulses Measurements for Inverted Polarity', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\nAmpl (V)','Integral\nAvg (nVS)','Integral\nStd (nVS)','Charge\nAvg (nC)','Charge\nStd (nC)'])
rowH.append(0.4*inch)

Vpulser = []
Itest = []
Qtest = []
for i in range(0,23):
    Qscope = []
    Iscope = []
    Vscope = []
    for j in range(0,25):
        Z = L[i*25 + j + 1].split(",")
        if(len(Z)==5):
            Vscope.append(-float(Z[2]))
            Iscope.append(float(Z[3]))
            Qscope.append(float(Z[4]))
    tdata.append([round(np.mean(Vscope),3),round(np.mean(Iscope),3),round(np.std(Iscope),4),round(np.mean(Qscope),3),round(np.std(Qscope),4)])
    rowH.append(0.22*inch)
    Vpulser.append(round(np.mean(Vscope),3))
    Itest.append(round(np.mean(Iscope),3))
    Qtest.append(round(np.mean(Qscope),3))

mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  Pulses measured\n"
mess +="directly by the MSO64B Scope with sample rate 3.125GS/S\n"
mess +="and an ADC resolution of 14-bits."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The average and standard deviation are based on 25\n"
mess +="repeated measurements made by the MSO64B Scope for\n"
mess +="each amplitude setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)
    
t4=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,25),(4,25)),
                ('BACKGROUND',(0,25),(4,25),colors.lemonchiffon),
                ('SPAN',(0,26),(4,26)),
                ('BACKGROUND',(0,26),(4,26),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,24),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,25),(4,25),2,colors.black),
                ('LINEABOVE',(0,26),(4,26),2,colors.black),
                ('LINEBEFORE',(1,1),(1,24),2,colors.black),
                ])

elements.append(t4)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup1.png",'rb')
elements.append(Image(f,width=6*inch, height=2.75*inch))
elements.append(PageBreak())

tdata = []
rowH = []
tdata.append(['ADC Measurements from ACMI for Inverted Beam Polarity', '','','','','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\n(Volts)','Qin\n(nC)','Beam','','Self Test (A-B)','','Self Test (B-A)',''])
rowH.append(0.22*inch)
tdata.append(['','','ADCA','ADCB','ADCA','ADCB','ADCA','ADCB'])
rowH.append(0.22*inch)

Vpulser = []
Qtest = []
BeamA = []
BeamB = []
STABA = []
STABB = []
STBAA = []
STBAB = []

for i in range(0,23):
    Qn = []
    BAn = []
    BBn = []
    STABAn = []
    STABBn= []
    STBAAn = []
    STBABn = []
    Vpulser.append(-(i+1))
    for j in range(0,16):
        Z = L[i*16 + j + 577].split(",")
        if(len(Z)==9):
            Qn.append(float(Z[2]))
            BAn.append(float(Z[3]))
            BBn.append(float(Z[4]))
            STABAn.append(float(Z[5]))
            STABBn.append(float(Z[6]))
            STBAAn.append(float(Z[7]))
            STBABn.append(float(Z[8]))
    tdata.append([-(i+1),round(np.mean(Qn),3),round(np.mean(BAn),1),round(np.mean(BBn),1),round(np.mean(STABAn),1),round(np.mean(STABBn),1),round(np.mean(STBAAn),1),round(np.mean(STBABn),1)])
    rowH.append(0.22*inch)

    Qtest.append(round(np.mean(Qn),3))
    BeamA.append(round(np.mean(BAn),3))
    BeamB.append(round(np.mean(BBn),3))
    STABA.append(round(np.mean(STABAn),3))
    STABB.append(round(np.mean(STABBn),3))
    STBAA.append(round(np.mean(STBAAn),3))
    STBAB.append(round(np.mean(STBABn),3))

mess = "HP8114A Pulse Generator was setup to produce 50 nSec wide pulses at the indicated voltages.\n"
mess +="Pulser connected to ICT Test Input.  ICT Output connected to ACMI Input.  ADC values read  \n"
mess +="from ACMI PLC over network using Python script."
tdata.append([mess,"","","","","","",""])
rowH.append(0.55*inch)
mess = "The averages are based on 16 repeated measurements made by the ACMI system for each amplitude\n"
mess +="setting of the HP8114A Pulse Generator."
tdata.append([mess,"","","","","","",""])
rowH.append(0.4*inch)

t5=Table(tdata,0.8*inch,rowH,style=[
                ('SPAN',(0,1),(0,2)),
                ('SPAN',(1,1),(1,2)),
                ('SPAN',(2,1),(3,1)),
                ('SPAN',(4,1),(5,1)),
                ('SPAN',(6,1),(7,1)),
                ('SPAN',(0,0),(7,0)),
                ('BACKGROUND',(0,0),(7,0),colors.lemonchiffon),
                ('SPAN',(0,26),(7,26)),
                ('BACKGROUND',(0,26),(7,26),colors.lemonchiffon),
                ('SPAN',(0,27),(7,27)),
                ('BACKGROUND',(0,27),(7,27),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,25),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(7,1),2,colors.black),
                ('LINEABOVE',(0,2),(7,2),2,colors.black),
                ('LINEABOVE',(0,3),(7,3),2,colors.black),
                ('LINEABOVE',(0,26),(7,26),2,colors.black),
                ('LINEABOVE',(0,27),(7,27),2,colors.black),
                ('LINEBEFORE',(1,1),(1,25),2,colors.black),
                ('LINEBEFORE',(2,1),(2,25),2,colors.black),
                ('LINEBEFORE',(4,1),(4,25),2,colors.black),
                ('LINEBEFORE',(6,1),(6,25),2,colors.black),
                ])

elements.append(t5)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup3.png",'rb')
elements.append(Image(f,width=6.7*inch, height=3*inch))
elements.append(PageBreak())

SAT = []
Qsat = []
for i in range(20,23):
    if(BeamA[i]==-2048):
        SAT.append(BeamA[i])
        Qsat.append(Qtest[i])
fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest,BeamA,'-o',markersize=6,label='ADC Data')
ax.plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Beam ACMI ADCA (Cnts)")
ax.legend(loc='lower right')
result='FAIL'
Npass=0
if(len(SAT)==3):
    result='PASS'
    Npass=Npass+1
ax.text(0.05, 0.95, 'PASS / FAIL Test:\nADCA Saturated for 3\nLargest Charges ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.tight_layout()
plt.savefig("Negative1.png")
f = open("Negative1.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

SAT = []
Qsat = []
for i in range(20,23):
    if(STABA[i]==-2048):
        SAT.append(STABA[i])
        Qsat.append(Qtest[i])
elements.append(Spacer(width=1,height=0.1*inch))
fr,ax = plt.subplots(1,2,figsize=(7,4))
ax[0].plot(Qtest,STABA,'-o',markersize=6,label='ADC Data')
ax[0].plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax[0].grid(True)
ax[0].set_xlabel("Qin (nC)")
ax[0].set_ylabel("ST(A-B) ACMI ADCA (Cnts)")
ax[0].legend(loc='lower right')
result='FAIL'
if(len(SAT)==3):
    result='PASS'
    Npass=Npass+1
ax[0].text(0.05, 0.95, 'PASS / FAIL Test:\nADCA Saturated for 3\nLargest Charges ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)

SAT = []
Qsat = []
for i in range(20,23):
    if(STBAB[i]==-2048):
        SAT.append(STBAB[i])
        Qsat.append(Qtest[i])
ax[1].plot(Qtest,STBAB,'-o',markersize=6, label='ADC Data')
ax[1].plot(Qsat,SAT,'ro',markersize=4,label='ADC Saturated')
ax[1].grid(True)
ax[1].set_xlabel("Qin (nC)")
ax[1].set_ylabel("ST(B-A) ACMI ADCB (Cnts)")
ax[1].legend(loc='lower right')
result='FAIL'
if(len(SAT)==3):
    result='PASS'
    Npass=Npass+1
ax[1].text(0.05, 0.95, 'PASS / FAIL Test:\nADCB Saturated for 3\nlargest Charges ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.tight_layout()
plt.savefig("Negative2.png")
f = open("Negative2.png",'rb')
elements.append(Image(f,width=7*inch, height=4*inch))
elements.append(PageBreak())

Beam = np.subtract(BeamA[0:18],BeamB[0:18])
STAB = np.subtract(STABA[0:18],STABB[0:18])
STBA = np.subtract(STBAB[0:18],STBAA[0:18])
Qtest = Qtest[0:18]

fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Beam,Qtest,'-o',linewidth=3,markersize=6,label='ADC Data')
ax.grid(True)
ax.set_ylabel("Qin (nC)")
ax.set_xlabel("Beam (A-B) (Cnts)")
pfit = np.polyfit(Beam,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(Beam,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*Beam[k] + pfit[0]*Beam[k]*Beam[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quadratic: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax.text(0.05, 0.93, mess,transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Npass=Npass+1
ax.text(0.5, 0.31, 'Correlation > 0.998 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Npass=Npass+1
ax.text(0.5, 0.24, 'RMSE < 100pC ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax.plot(Beam,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax.legend(loc='lower right')
plt.tight_layout()
plt.savefig("Negative3.png")
f = open("Negative3.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

fr,ax = plt.subplots(1,2,figsize=(7,4))
ax[0].plot(STAB,Qtest,'-o',linewidth=3,markersize=6,label='ADC Data')
ax[0].grid(True)
ax[0].set_ylabel("Qin (nC)")
ax[0].set_xlabel("Self Test(A-B) (Cnts)")
pfit = np.polyfit(STAB,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(STAB,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*STAB[k] + pfit[0]*STAB[k]*STAB[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quad: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax[0].text(0.05, 0.93, mess,transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[0].text(0.45, 0.42, 'PASS / FAIL Tests:',
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Npass=Npass+1
ax[0].text(0.4, 0.33, 'Corr>0.998 ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Npass=Npass+1
ax[0].text(0.4, 0.24, 'RMSE<100pC ? '+result,
    transform=ax[0].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[0].plot(STAB,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax[0].legend(loc='lower right')

ax[1].plot(STBA,Qtest,'-o',linewidth=3,markersize=6, label='ADC Data')
ax[1].grid(True)
ax[1].set_ylabel("Qin (nC)")
ax[1].set_xlabel("Self Test(B-A) (Cnts)")
pfit = np.polyfit(STBA,np.multiply(Qtest,1000),2)
FitCoef = np.corrcoef(STBA,Qtest)
Qcal = []
Qerr = []
for k in range(0,18):
    Qcal.append(pfit[2] + pfit[1]*STBA[k] + pfit[0]*STBA[k]*STBA[k])
    Qerr.append(1000.0*Qtest[k] - Qcal[k])
Qcal = np.divide(Qcal,1000) #Convert from pC to nC
Qrmse = np.sqrt(sum(np.multiply(Qerr,Qerr))/len(Qerr))
mess = 'Quad: '+str(round(pfit[0],6))+'pC/Cnt/Cnt\nLinear: '+str(round(pfit[1],4))+'pC/Cnt\nOffset:'+str(round(pfit[2],3))+'pC\nCorrelation:'+str(round(FitCoef[0][1],4))+'\nRMSE: '+str(round(Qrmse,3))+'pC'
ax[1].text(0.05, 0.93, mess,transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[1].text(0.45, 0.42, 'PASS / FAIL Tests:',
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Npass=Npass+1
ax[1].text(0.4, 0.33, 'Corr>0.998 ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrmse<100):
    result='PASS'
    Npass=Npass+1
ax[1].text(0.4, 0.24, 'RMSE<100pC ? '+result,
    transform=ax[1].transAxes, fontsize=10,verticalalignment='top', bbox=props)
ax[1].plot(STBA,Qcal,'-o',markersize=4,label='Quadratic Fit')
ax[1].legend(loc='lower right')

plt.tight_layout()
plt.savefig("Negative4.png")
f = open("Negative4.png",'rb')
elements.append(Image(f,width=7*inch, height=4*inch))
elements.append(PageBreak())

###########################################################################################
# Start Processing the ACMI Verification Data File for Normal Beam Polarity
###########################################################################################
with open(fverify) as f:
    L = f.readlines()
    L = [x.strip('\n') for x in L]

tdata = []
rowH = []
tdata.append(['Test Pulses Measurements for ACMI Verification', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Test Pulse\nAmpl (V)','Integral\nAvg (nVS)','Integral\nStd (nVS)','Charge\nAvg (nC)','Charge\nStd (nC)'])
rowH.append(0.4*inch)

Vpulser = []
Itest = []
Qtest = []
for i in range(0,23):
    Qscope = []
    Iscope = []
    Vscope = []
    for j in range(0,25):
        Z = L[i*25 + j].split(",")
        print(Z)
        if(len(Z)==5):
            Vscope.append(float(Z[2]))
            Iscope.append(float(Z[3]))
            Qscope.append(float(Z[4]))
    tdata.append([round(np.mean(Vscope),3),round(np.mean(Iscope),3),round(np.std(Iscope),4),round(np.mean(Qscope),3),round(np.std(Qscope),4)])
    rowH.append(0.22*inch)
    Vpulser.append(round(np.mean(Vscope),3))
    Itest.append(round(np.mean(Iscope),3))
    Qtest.append(round(np.mean(Qscope),3))

mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  Pulses measured\n"
mess +="directly by the MSO64B Scope with sample rate 3.125GS/S\n"
mess +="and an ADC resolution of 14-bits."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The average and standard deviation are based on 25\n"
mess +="repeated measurements made by the MSO64B Scope for\n"
mess +="each amplitude setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)
    
t4=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,25),(4,25)),
                ('BACKGROUND',(0,25),(4,25),colors.lemonchiffon),
                ('SPAN',(0,26),(4,26)),
                ('BACKGROUND',(0,26),(4,26),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,24),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,25),(4,25),2,colors.black),
                ('LINEABOVE',(0,26),(4,26),2,colors.black),
                ('LINEBEFORE',(1,1),(1,24),2,colors.black),
                ])

elements.append(t4)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup1.png",'rb')
elements.append(Image(f,width=6*inch, height=2.75*inch))
elements.append(PageBreak())

tdata = []
rowH = []
tdata.append(['ACMI Charge Measurements for Verification', '','','',''])
rowH.append(0.22*inch)
tdata.append(['Pulse\n(V)','Qin\n(nC)','Beam\n(nC)','ST(A-B)\n(nC)','ST(B-A)\n(nC)'])
rowH.append(0.4*inch)

Vpulser = []
Qtest = []
Beam = []
STAB = []
STBA = []
for i in range(0,23):
    Z = L[i+575].split(",")
    if(len(Z)==6):
        Vpulser.append(float(Z[1]))
        Qtest.append(float(Z[2]))
        Beam.append(float(Z[3]))
        STAB.append(float(Z[4]))
        STBA.append(float(Z[5]))
        tdata.append([Vpulser[i],Qtest[i],Beam[i],STAB[i],STBA[i]])
    rowH.append(0.22*inch)

mess = "HP8114A Pulse Generator was setup to produce 50 nSec\n"
mess +="wide pulses at the indicated voltages.  Pulses measured\n"
mess +="by the ACMI system.  Python script reads appropriate PLC\n"
mess +="tag to obtain the charge values."
tdata.append([mess,"","","",""])
rowH.append(0.75*inch)
mess = "The charge values are an average of 16 repeated \n"
mess +="measurements made by the ACMI system for each amplitude\n"
mess +="setting."
tdata.append([mess,"","","",""])
rowH.append(0.55*inch)

t6=Table(tdata,0.8*inch,rowHeights=rowH,style=[
                ('SPAN',(0,0),(4,0)),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('SPAN',(0,25),(4,25)),
                ('BACKGROUND',(0,25),(4,25),colors.lemonchiffon),
                ('SPAN',(0,26),(4,26)),
                ('BACKGROUND',(0,26),(4,26),colors.lemonchiffon),
                ('BACKGROUND',(0,1),(0,24),colors.lightblue),
                ('GRID',(0,0),(-1,-1),0.5,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('LINEABOVE',(0,2),(4,2),2,colors.black),
                ('LINEABOVE',(0,25),(4,25),2,colors.black),
                ('LINEABOVE',(0,26),(4,26),2,colors.black),
                ('LINEBEFORE',(1,1),(1,24),2,colors.black),
                ])

elements.append(t6)

elements.append(Spacer(width=1,height=0.1*inch))
f = open("Setup3.png",'rb')
elements.append(Image(f,width=6*inch, height=2.75*inch))
elements.append(PageBreak())

fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest[0:19],STAB[0:19],'-o',markersize=6)
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Self Test (A-B) (nC)")
pfit = np.polyfit(Qtest[0:19],STAB[0:19],1)
FitCoef = np.corrcoef(Qtest[0:19],STAB[0:19])
Qrms = np.sqrt(np.mean(np.power(np.subtract(Qtest[0:19],STAB[0:19]),2)))

mess = 'Linear: '+str(round(pfit[0],4))+'nC/nC\nOffset:'+str(round(pfit[1],3))+'nC\nCorrelation:'+str(round(FitCoef[0][1],4))
mess = mess + '\nRMS Error:'+str(round(Qrms,4))
ax.text(0.05, 0.93, mess,
    transform=ax.transAxes, fontsize=12,verticalalignment='top', bbox=props)
ax.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
Vpass=0
if(pfit[0]<1.02 and pfit[0]>0.98):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.31, '0.98 < Slope < 1.02 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(pfit[1]<0.2 and pfit[0]>-0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.24, '-0.2 < Intercept < 0.2 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.17, 'Correlation > 0.998 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrms<0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.1, 'RMS Error < 0.200 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.savefig("Verify1.png")
f = open("Verify1.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest[0:19],STBA[0:19],'-o',markersize=6)
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Self Test (B-A) (nC)")
pfit = np.polyfit(Qtest[0:19],STBA[0:19],1)
FitCoef = np.corrcoef(Qtest[0:19],STBA[0:19])
Qrms = np.sqrt(np.mean(np.power(np.subtract(Qtest[0:19],STBA[0:19]),2)))

mess = 'Linear: '+str(round(pfit[0],4))+'nC/nC\nOffset:'+str(round(pfit[1],3))+'nC\nCorrelation:'+str(round(FitCoef[0][1],4))
mess = mess + '\nRMS Error:'+str(round(Qrms,4))
ax.text(0.05, 0.93, mess,
    transform=ax.transAxes, fontsize=12,verticalalignment='top', bbox=props)
ax.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'

if(pfit[0]<1.02 and pfit[0]>0.98):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.31, '0.98 < Slope < 1.02 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(pfit[1]<0.2 and pfit[0]>-0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.24, '-0.2 < Intercept < 0.2 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.17, 'Correlation > 0.998 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrms<0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.1, 'RMS Error < 0.200 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.savefig("Verify2.png")
f = open("Verify2.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))
elements.append(PageBreak())

fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest[0:19],Beam[0:19],'-o',markersize=6)
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Beam (nC)")
pfit = np.polyfit(Qtest[0:19],Beam[0:19],1)
FitCoef = np.corrcoef(Qtest[0:19],Beam[0:19])
Qrms = np.sqrt(np.mean(np.power(np.subtract(Qtest[0:19],Beam[0:19]),2)))

mess = 'Linear: '+str(round(pfit[0],4))+'nC/nC\nOffset:'+str(round(pfit[1],3))+'nC\nCorrelation:'+str(round(FitCoef[0][1],4))
mess = mess + '\nRMS Error:'+str(round(Qrms,4))
ax.text(0.05, 0.93, mess,
    transform=ax.transAxes, fontsize=12,verticalalignment='top', bbox=props)
ax.text(0.5, 0.38, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'

if(pfit[0]<1.02 and pfit[0]>0.98):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.31, '0.98 < Slope < 1.02 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(pfit[1]<0.2 and pfit[0]>-0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.24, '-0.2 < Intercept < 0.2 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(FitCoef[0][1]>0.998):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.17, 'Correlation > 0.998 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qrms<0.2):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.1, 'RMS Error < 0.200 ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
plt.savefig("Verify3.png")
f = open("Verify3.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))

Qerr = np.multiply(np.divide(np.subtract(Qtest[0:19],Beam[0:19]),Qtest[0:19]),100.0)
Qerr = np.abs(Qerr)
fr,ax = plt.subplots(1,1,figsize=(5,5))
ax.plot(Qtest[0:19],Qerr,'-o',markersize=6)
ax.grid(True)
ax.set_xlabel("Qin (nC)")
ax.set_ylabel("Qerr = 100.0*(Qin-Beam)/Qin (%)")
ax.text(0.5, 0.88, 'PASS / FAIL Tests:',
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Qerr[18]<1.5):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.81, 'F.S.Error < 1.5% ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(max(Qerr)<6.0):
    result='PASS'
    Vpass=Vpass+1
ax.text(0.4, 0.74, 'Max Error < 6% ? '+result,
    transform=ax.transAxes, fontsize=10,verticalalignment='top', bbox=props)
result='FAIL'
if(Vpass==14.0):
    result='PASS'
ax.text(0.3, 0.67, 'Verification Result ? '+result,
    transform=ax.transAxes, fontsize=14,verticalalignment='top', bbox=props)
plt.savefig("Verify4.png")
f = open("Verify4.png",'rb')
elements.append(Image(f,width=5*inch, height=5*inch))
elements.append(PageBreak())

######################################################################################
# Report Summary Table:
######################################################################################

tdata  = []
tdata.append(['ACMI Calibration Report Summary','','','',''])
result='FAILED'
if(Rpass==3): result='PASSED'
tdata.append(['All 3 ICT Ratio Measurement Tests','','','',result])
result='FAILED'
if(Ppass==9): result='PASSED'
tdata.append(['All 9 ACMI Calibration Tests','','','',result])
result='FAILED'
if(Npass==9): result='PASSED'
tdata.append(['All 9 Inverted Polarity Tests','','','',result])
result='FAILED'
if(Vpass==14): result='PASSED'
tdata.append(['All 14 Verification Tests','','','',result])
result='FAILED'
if((Rpass+Ppass+Npass+Vpass)==35): result='PASSED'
tdata.append(['Procedure Status','','','',result])
tdata.append(['New PLC Calibration Constants','','','Quadratic',str(PLCquad)])
tdata.append(['','','','Linear',str(PLClinear)])
tdata.append(['','','','Offset',str(PLCoffset)])
rows = 9*[0.25*inch]
rows[0] = 0.5*inch
tend=Table(tdata,1*inch,rows,style=[
                ('SPAN',(0,0),(4,0)),
                ('FONTSIZE', (0,0), (4,0), 14),
                ('VALIGN',(0,0),(4,0),'MIDDLE'),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('SPAN',(0,1),(3,1)),
                ('SPAN',(0,2),(3,2)),
                ('SPAN',(0,3),(3,3)),
                ('SPAN',(0,4),(3,4)),
                ('SPAN',(0,5),(3,5)),
                ('SPAN',(0,6),(2,6)),
                ('SPAN',(0,7),(2,7)),
                ('SPAN',(0,8),(2,8)),
                ('SPAN',(0,6),(2,8)),
                ('VALIGN',(0,6),(2,8),'MIDDLE'),
                ('GRID',(0,0),(-1,-1),1,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('BACKGROUND',(0,1),(3,8),colors.lemonchiffon),
                ])

elements.append(tend)

tdata = []
tdata.append(['Final Actions to Closeout Procedure'])
tdata.append(['Calibration Constants Updated in PLC?','','','',PLCupdated])
tdata.append(['PLC Safety Signature Generated?','','','Status',PLCsignature])
tdata.append(['','','','Value',PLCSSValue])
tdata.append(['PLC Key set to Run Position?','','','',PLCrun])
tdata.append(['ACMI Interlock Key Set to Bypass?','','','',ACMIbypass])
tdata.append(['ECN Requested for PLC Changes?','','','',ECNrequest])
tdata.append(['Procedure: NSLSII-INS-PRC-001 Status?','','','',ProcStatus])
rows = 8*[0.25*inch]
rows[0] = 0.5*inch

tend=Table(tdata,1*inch,rows,style=[
                ('SPAN',(0,0),(4,0)),
                ('FONTSIZE', (0,0), (4,0), 14),
                ('VALIGN',(0,0),(4,0),'MIDDLE'),
                ('BACKGROUND',(0,0),(4,0),colors.lemonchiffon),
                ('LINEABOVE',(0,1),(4,1),2,colors.black),
                ('SPAN',(0,1),(3,1)),
                ('SPAN',(0,2),(2,2)),
                ('SPAN',(0,3),(2,3)),
                ('SPAN',(0,2),(2,3)),
                ('SPAN',(0,4),(3,4)),
                ('SPAN',(0,5),(3,5)),
                ('SPAN',(0,6),(3,6)),
                ('SPAN',(0,7),(3,7)),
                ('VALIGN',(0,2),(2,3),'MIDDLE'),
                ('GRID',(0,0),(-1,-1),1,colors.black),
                ('BOX',(0,0),(-1,-1),2,colors.black),
                ('BACKGROUND',(0,1),(3,7),colors.lemonchiffon),
                ])
elements.append(Spacer(width=1,height=0.3*inch))
elements.append(tend)
doc.build(elements)
'''

